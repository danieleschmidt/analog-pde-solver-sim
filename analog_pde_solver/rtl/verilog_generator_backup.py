"""Verilog RTL generation for analog PDE solver hardware."""

import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
import textwrap
from ..utils.logging_config import get_logger


@dataclass
class RTLConfig:
    """Configuration for RTL generation."""
    target_technology: str = "xilinx_ultrascale"
    clock_frequency_mhz: float = 100.0
    dac_bits: int = 8
    adc_bits: int = 10
    enable_pipeline: bool = True
    enable_parallel_crossbars: bool = True
    memory_type: str = "bram"  # bram, uram, distributed
    optimization_goal: str = "area"  # area, speed, power


class VerilogGenerator:
    """Generate optimized Verilog RTL for analog PDE solver hardware."""
    
    def __init__(self, config: RTLConfig = None):
        """Initialize Verilog generator.
        
        Args:
            config: RTL generation configuration
        """
        self.config = config or RTLConfig()
        self.logger = get_logger('verilog_generator')
        
        # Module templates and libraries
        self.module_templates = {}
        self.generated_modules = {}
        
        self.logger.info(f"Verilog generator initialized for {self.config.target_technology}")
    
    def generate_top_level(
        self,
        crossbar_size: int,
        num_crossbars: int = 1,
        pde_type: str = "poisson"
    ) -> str:
        """Generate top-level module for PDE solver.
        
        Args:
            crossbar_size: Size of crossbar arrays
            num_crossbars: Number of parallel crossbar arrays
            pde_type: Type of PDE being solved
            
        Returns:
            Verilog source code for top-level module
        """
        self.logger.info(f"Generating top-level module: {crossbar_size}x{crossbar_size}, {num_crossbars} crossbars")
        
        module_name = f"analog_pde_solver_{pde_type}"
        
        # Generate module header
        header = self._generate_module_header(
            module_name, crossbar_size, num_crossbars
        )
        
        # Generate internal signals
        signals = self._generate_internal_signals(
            crossbar_size, num_crossbars
        )
        
        # Generate crossbar instances
        crossbar_instances = self._generate_crossbar_instances(
            crossbar_size, num_crossbars
        )
        
        # Generate control logic
        control_logic = self._generate_control_logic(
            crossbar_size, num_crossbars, pde_type
        )
        
        # Generate DAC/ADC interfaces
        analog_interfaces = self._generate_analog_interfaces(
            crossbar_size, num_crossbars
        )
        
        # Combine all parts
        verilog_code = f"""{header}

{signals}

{crossbar_instances}

{control_logic}

{analog_interfaces}

endmodule
"""
        
        self.generated_modules[module_name] = verilog_code
        return verilog_code\n    \n    def generate_crossbar_array(self, size: int) -> str:\n        \"\"\"Generate crossbar array module.\n        \n        Args:\n            size: Crossbar array size (NxN)\n            \n        Returns:\n            Verilog source code for crossbar array\n        \"\"\"\n        module_name = f\"analog_crossbar_array_{size}x{size}\"\n        \n        # Module header\n        header = f\"\"\"\nmodule {module_name} #(\n    parameter ARRAY_SIZE = {size},\n    parameter G_BITS = 12,  // Conductance resolution\n    parameter V_BITS = {self.config.dac_bits},  // Input voltage bits\n    parameter I_BITS = {self.config.adc_bits}   // Output current bits\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Programming interface\n    input wire program_en,\n    input wire [G_BITS-1:0] program_g_data,\n    input wire [$clog2(ARRAY_SIZE*ARRAY_SIZE)-1:0] program_addr,\n    \n    // Analog computation interface\n    input wire [V_BITS-1:0] row_voltages [0:ARRAY_SIZE-1],\n    output reg [I_BITS-1:0] col_currents [0:ARRAY_SIZE-1],\n    \n    // Status signals\n    output wire ready,\n    output wire [7:0] status\n);\"\"\"\n        \n        # Internal memory for conductances\n        memory = f\"\"\"\n    // Conductance memory (positive and negative)\n    (* ram_style = \"{self.config.memory_type}\" *)\n    reg [G_BITS-1:0] g_positive [0:ARRAY_SIZE*ARRAY_SIZE-1];\n    (* ram_style = \"{self.config.memory_type}\" *)\n    reg [G_BITS-1:0] g_negative [0:ARRAY_SIZE*ARRAY_SIZE-1];\n    \n    // Programming logic\n    always @(posedge clk) begin\n        if (!rst_n) begin\n            // Initialize to minimum conductance\n            for (int i = 0; i < ARRAY_SIZE*ARRAY_SIZE; i++) begin\n                g_positive[i] <= {{G_BITS{{1'b0}}}};\n                g_negative[i] <= {{G_BITS{{1'b0}}}};\n            end\n        end else if (program_en) begin\n            // Program conductances (simplified)\n            if (program_addr < ARRAY_SIZE*ARRAY_SIZE) begin\n                g_positive[program_addr] <= program_g_data;\n                g_negative[program_addr] <= program_g_data;\n            end\n        end\n    end\"\"\"\n        \n        # Analog computation (behavioral model)\n        computation = self._generate_crossbar_computation(size)\n        \n        # Status and control\n        status_logic = f\"\"\"\n    // Status signals\n    reg [7:0] status_reg;\n    reg ready_reg;\n    \n    assign status = status_reg;\n    assign ready = ready_reg;\n    \n    always @(posedge clk) begin\n        if (!rst_n) begin\n            status_reg <= 8'h00;\n            ready_reg <= 1'b0;\n        end else begin\n            ready_reg <= 1'b1;  // Always ready for now\n            status_reg[0] <= program_en;\n            status_reg[7:1] <= 7'b0;\n        end\n    end\"\"\"\n        \n        verilog_code = f\"{header}\\n\\n{memory}\\n\\n{computation}\\n\\n{status_logic}\\n\\nendmodule\\n\"\n        \n        self.generated_modules[module_name] = verilog_code\n        return verilog_code\n    \n    def generate_pde_controller(\n        self,\n        crossbar_size: int,\n        pde_type: str = \"poisson\"\n    ) -> str:\n        \"\"\"Generate PDE-specific control logic.\n        \n        Args:\n            crossbar_size: Size of crossbar arrays\n            pde_type: Type of PDE (poisson, heat, wave, navier_stokes)\n            \n        Returns:\n            Verilog source code for PDE controller\n        \"\"\"\n        module_name = f\"pde_controller_{pde_type}\"\n        \n        # Different control logic for different PDE types\n        if pde_type == \"poisson\":\n            control_logic = self._generate_poisson_controller(crossbar_size)\n        elif pde_type == \"heat\":\n            control_logic = self._generate_heat_controller(crossbar_size)\n        elif pde_type == \"navier_stokes\":\n            control_logic = self._generate_navier_stokes_controller(crossbar_size)\n        else:\n            control_logic = self._generate_generic_controller(crossbar_size)\n        \n        self.generated_modules[module_name] = control_logic\n        return control_logic\n    \n    def generate_mixed_signal_interface(self, crossbar_size: int) -> str:\n        \"\"\"Generate mixed-signal interface modules.\n        \n        Args:\n            crossbar_size: Size of crossbar arrays\n            \n        Returns:\n            Verilog source code for mixed-signal interfaces\n        \"\"\"\n        # DAC array\n        dac_module = self._generate_dac_array(crossbar_size)\n        \n        # ADC array\n        adc_module = self._generate_adc_array(crossbar_size)\n        \n        combined = f\"{dac_module}\\n\\n{adc_module}\\n\"\n        \n        self.generated_modules[\"mixed_signal_interface\"] = combined\n        return combined\n    \n    def _generate_module_header(\n        self,\n        module_name: str,\n        crossbar_size: int,\n        num_crossbars: int\n    ) -> str:\n        \"\"\"Generate module header with ports.\"\"\"\n        return f\"\"\"\n// Analog PDE Solver - Generated by Terragon Labs\n// Target: {self.config.target_technology}\n// Clock: {self.config.clock_frequency_mhz} MHz\n\nmodule {module_name} #(\n    parameter GRID_SIZE = {crossbar_size},\n    parameter NUM_CROSSBARS = {num_crossbars},\n    parameter DAC_BITS = {self.config.dac_bits},\n    parameter ADC_BITS = {self.config.adc_bits},\n    parameter MAX_ITERATIONS = 1000\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Configuration interface\n    input wire [31:0] config_data,\n    input wire config_valid,\n    output wire config_ready,\n    \n    // Boundary conditions input\n    input wire [DAC_BITS-1:0] boundary_values [0:GRID_SIZE-1],\n    input wire boundary_valid,\n    \n    // Solution output\n    output wire [ADC_BITS-1:0] solution [0:GRID_SIZE-1],\n    output wire solution_valid,\n    \n    // Control signals\n    input wire start_solve,\n    output wire solve_complete,\n    output wire converged,\n    output wire [15:0] iterations_count,\n    \n    // Status and debug\n    output wire [31:0] debug_status,\n    output wire error\n);\"\"\"\n    \n    def _generate_internal_signals(\n        self,\n        crossbar_size: int,\n        num_crossbars: int\n    ) -> str:\n        \"\"\"Generate internal signal declarations.\"\"\"\n        return f\"\"\"\n    // Internal signals\n    reg [31:0] iteration_counter;\n    reg [2:0] solver_state;\n    reg [DAC_BITS-1:0] current_solution [0:GRID_SIZE-1];\n    reg [DAC_BITS-1:0] prev_solution [0:GRID_SIZE-1];\n    \n    // Crossbar interface signals\n    wire [DAC_BITS-1:0] crossbar_inputs [0:NUM_CROSSBARS-1][0:GRID_SIZE-1];\n    wire [ADC_BITS-1:0] crossbar_outputs [0:NUM_CROSSBARS-1][0:GRID_SIZE-1];\n    wire [NUM_CROSSBARS-1:0] crossbar_ready;\n    \n    // Convergence detection\n    wire convergence_check;\n    reg [ADC_BITS-1:0] error_metric;\n    \n    // State machine states\n    localparam STATE_IDLE = 3'b000;\n    localparam STATE_INIT = 3'b001;\n    localparam STATE_COMPUTE = 3'b010;\n    localparam STATE_UPDATE = 3'b011;\n    localparam STATE_CHECK = 3'b100;\n    localparam STATE_DONE = 3'b101;\"\"\"\n    \n    def _generate_crossbar_instances(\n        self,\n        crossbar_size: int,\n        num_crossbars: int\n    ) -> str:\n        \"\"\"Generate crossbar array instances.\"\"\"\n        instances = []\n        \n        for i in range(num_crossbars):\n            instance = f\"\"\"\n    // Crossbar array instance {i}\n    analog_crossbar_array_{crossbar_size}x{crossbar_size} crossbar_{i} (\n        .clk(clk),\n        .rst_n(rst_n),\n        .program_en(1'b0),  // Programming handled separately\n        .program_g_data(12'b0),\n        .program_addr({crossbar_size * crossbar_size}'b0),\n        .row_voltages(crossbar_inputs[{i}]),\n        .col_currents(crossbar_outputs[{i}]),\n        .ready(crossbar_ready[{i}]),\n        .status()\n    );\"\"\"\n            instances.append(instance)\n        \n        return \"\\n\".join(instances)\n    \n    def _generate_control_logic(\n        self,\n        crossbar_size: int,\n        num_crossbars: int,\n        pde_type: str\n    ) -> str:\n        \"\"\"Generate main control logic state machine.\"\"\"\n        return f\"\"\"\n    // Main control state machine\n    always @(posedge clk) begin\n        if (!rst_n) begin\n            solver_state <= STATE_IDLE;\n            iteration_counter <= 32'b0;\n            solution_valid <= 1'b0;\n            solve_complete <= 1'b0;\n            converged <= 1'b0;\n        end else begin\n            case (solver_state)\n                STATE_IDLE: begin\n                    if (start_solve && boundary_valid) begin\n                        solver_state <= STATE_INIT;\n                        iteration_counter <= 32'b0;\n                        solution_valid <= 1'b0;\n                        solve_complete <= 1'b0;\n                    end\n                end\n                \n                STATE_INIT: begin\n                    // Initialize solution with boundary conditions\n                    for (int i = 0; i < GRID_SIZE; i++) begin\n                        current_solution[i] <= boundary_values[i];\n                        prev_solution[i] <= boundary_values[i];\n                    end\n                    solver_state <= STATE_COMPUTE;\n                end\n                \n                STATE_COMPUTE: begin\n                    // Set up crossbar inputs\n                    for (int cb = 0; cb < NUM_CROSSBARS; cb++) begin\n                        for (int i = 0; i < GRID_SIZE; i++) begin\n                            crossbar_inputs[cb][i] <= current_solution[i];\n                        end\n                    end\n                    \n                    if (&crossbar_ready) begin\n                        solver_state <= STATE_UPDATE;\n                    end\n                end\n                \n                STATE_UPDATE: begin\n                    // Update solution based on crossbar outputs\n                    for (int i = 0; i < GRID_SIZE; i++) begin\n                        prev_solution[i] <= current_solution[i];\n                        // Jacobi update with damping\n                        current_solution[i] <= current_solution[i] - \n                            (crossbar_outputs[0][i] >> 3);  // Divide by 8 for damping\n                    end\n                    \n                    iteration_counter <= iteration_counter + 1;\n                    solver_state <= STATE_CHECK;\n                end\n                \n                STATE_CHECK: begin\n                    // Check convergence or max iterations\n                    if (convergence_check || iteration_counter >= MAX_ITERATIONS) begin\n                        solver_state <= STATE_DONE;\n                        converged <= convergence_check;\n                        solve_complete <= 1'b1;\n                        solution_valid <= 1'b1;\n                        \n                        // Copy final solution to output\n                        for (int i = 0; i < GRID_SIZE; i++) begin\n                            solution[i] <= current_solution[i];\n                        end\n                    end else begin\n                        solver_state <= STATE_COMPUTE;\n                    end\n                end\n                \n                STATE_DONE: begin\n                    if (!start_solve) begin\n                        solver_state <= STATE_IDLE;\n                    end\n                end\n                \n                default: solver_state <= STATE_IDLE;\n            endcase\n        end\n    end\n    \n    // Output assignments\n    assign iterations_count = iteration_counter[15:0];\n    assign debug_status = {{24'b0, solver_state, 5'b0}};\n    assign error = 1'b0;  // No errors for now\"\"\"\n    \n    def _generate_analog_interfaces(\n        self,\n        crossbar_size: int,\n        num_crossbars: int\n    ) -> str:\n        \"\"\"Generate analog interface instantiations.\"\"\"\n        return f\"\"\"\n    // Convergence detection logic\n    convergence_detector conv_detect (\n        .clk(clk),\n        .rst_n(rst_n),\n        .current_solution(current_solution),\n        .prev_solution(prev_solution),\n        .grid_size(GRID_SIZE),\n        .threshold(16'h0010),  // Convergence threshold\n        .converged(convergence_check)\n    );\"\"\"\n    \n    def _generate_crossbar_computation(self, size: int) -> str:\n        \"\"\"Generate crossbar computation logic.\"\"\"\n        return f\"\"\"\n    // Analog crossbar computation (behavioral model)\n    // In real hardware, this would be analog circuits\n    \n    genvar row, col;\n    generate\n        for (row = 0; row < ARRAY_SIZE; row++) begin : row_gen\n            reg [I_BITS+8-1:0] row_current_sum;\n            \n            always @(posedge clk) begin\n                if (!rst_n) begin\n                    row_current_sum <= {{I_BITS+8{{1'b0}}}};\n                end else begin\n                    row_current_sum <= {{I_BITS+8{{1'b0}}}};\n                    \n                    // Behavioral model: I = G * V\n                    for (int col = 0; col < ARRAY_SIZE; col++) begin\n                        // Multiply conductance by voltage (simplified)\n                        row_current_sum <= row_current_sum + \n                            (g_positive[row*ARRAY_SIZE + col] * row_voltages[col]) - \n                            (g_negative[row*ARRAY_SIZE + col] * row_voltages[col]);\n                    end\n                end\n            end\n            \n            // Saturate and assign output\n            always @(posedge clk) begin\n                if (row_current_sum[I_BITS+8-1:I_BITS] != 0) begin\n                    // Saturate\n                    col_currents[row] <= {{I_BITS{{1'b1}}}};\n                end else begin\n                    col_currents[row] <= row_current_sum[I_BITS-1:0];\n                end\n            end\n        end\n    endgenerate\"\"\"\n    \n    def _generate_poisson_controller(self, size: int) -> str:\n        \"\"\"Generate Poisson-specific controller.\"\"\"\n        return f\"\"\"\n// Poisson equation controller\nmodule pde_controller_poisson #(\n    parameter GRID_SIZE = {size}\n)(\n    input wire clk,\n    input wire rst_n,\n    // Add specific Poisson control signals\n    output wire [31:0] poisson_status\n);\n    // Poisson-specific control logic\n    assign poisson_status = 32'h00000001;  // Active\nendmodule\"\"\"\n    \n    def _generate_dac_array(self, size: int) -> str:\n        \"\"\"Generate DAC array module.\"\"\"\n        return f\"\"\"\n// DAC Array Module\nmodule dac_array #(\n    parameter ARRAY_SIZE = {size},\n    parameter DAC_BITS = {self.config.dac_bits}\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire [DAC_BITS-1:0] digital_in [0:ARRAY_SIZE-1],\n    output reg [ARRAY_SIZE-1:0] analog_out,  // Simplified analog representation\n    input wire convert_start,\n    output wire convert_done\n);\n    \n    reg [7:0] conversion_delay;\n    \n    always @(posedge clk) begin\n        if (!rst_n) begin\n            conversion_delay <= 8'b0;\n            analog_out <= {{ARRAY_SIZE{{1'b0}}}};\n        end else if (convert_start) begin\n            if (conversion_delay < 8'd10) begin  // 10 cycle conversion\n                conversion_delay <= conversion_delay + 1;\n            end else begin\n                // Convert digital to analog (simplified)\n                for (int i = 0; i < ARRAY_SIZE; i++) begin\n                    analog_out[i] <= digital_in[i][DAC_BITS-1];  // MSB as analog\n                end\n                conversion_delay <= 8'b0;\n            end\n        end\n    end\n    \n    assign convert_done = (conversion_delay == 8'd10);\n    \nendmodule\"\"\"\n    \n    def _generate_adc_array(self, size: int) -> str:\n        \"\"\"Generate ADC array module.\"\"\"\n        return f\"\"\"\n// ADC Array Module\nmodule adc_array #(\n    parameter ARRAY_SIZE = {size},\n    parameter ADC_BITS = {self.config.adc_bits}\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire [ARRAY_SIZE-1:0] analog_in,  // Simplified analog input\n    output reg [ADC_BITS-1:0] digital_out [0:ARRAY_SIZE-1],\n    input wire sample_start,\n    output wire sample_done\n);\n    \n    reg [7:0] sampling_delay;\n    \n    always @(posedge clk) begin\n        if (!rst_n) begin\n            sampling_delay <= 8'b0;\n            for (int i = 0; i < ARRAY_SIZE; i++) begin\n                digital_out[i] <= {{ADC_BITS{{1'b0}}}};\n            end\n        end else if (sample_start) begin\n            if (sampling_delay < 8'd15) begin  // 15 cycle sampling\n                sampling_delay <= sampling_delay + 1;\n            end else begin\n                // Convert analog to digital (simplified)\n                for (int i = 0; i < ARRAY_SIZE; i++) begin\n                    digital_out[i] <= {{analog_in[i], {{ADC_BITS-1{{1'b0}}}}}};\n                end\n                sampling_delay <= 8'b0;\n            end\n        end\n    end\n    \n    assign sample_done = (sampling_delay == 8'd15);\n    \nendmodule\"\"\"\n    \n    def _generate_generic_controller(self, size: int) -> str:\n        \"\"\"Generate generic PDE controller.\"\"\"\n        return f\"\"\"\n// Generic PDE controller\nmodule pde_controller_generic #(\n    parameter GRID_SIZE = {size}\n)(\n    input wire clk,\n    input wire rst_n,\n    output wire [31:0] generic_status\n);\n    assign generic_status = 32'h00000000;\nendmodule\"\"\"\n    \n    def generate_convergence_detector(self) -> str:\n        \"\"\"Generate convergence detection module.\"\"\"\n        return f\"\"\"\n// Convergence Detection Module\nmodule convergence_detector #(\n    parameter GRID_SIZE = 128,\n    parameter DATA_BITS = {self.config.adc_bits}\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire [DATA_BITS-1:0] current_solution [0:GRID_SIZE-1],\n    input wire [DATA_BITS-1:0] prev_solution [0:GRID_SIZE-1],\n    input wire [15:0] grid_size,\n    input wire [15:0] threshold,\n    output reg converged\n);\n    \n    reg [DATA_BITS+8-1:0] error_accumulator;\n    reg [15:0] element_counter;\n    \n    always @(posedge clk) begin\n        if (!rst_n) begin\n            error_accumulator <= {{DATA_BITS+8{{1'b0}}}};\n            element_counter <= 16'b0;\n            converged <= 1'b0;\n        end else begin\n            // Calculate L2 norm of difference\n            error_accumulator <= {{DATA_BITS+8{{1'b0}}}};\n            \n            for (int i = 0; i < GRID_SIZE; i++) begin\n                if (i < grid_size) begin\n                    error_accumulator <= error_accumulator + \n                        ((current_solution[i] > prev_solution[i]) ?\n                         (current_solution[i] - prev_solution[i]) :\n                         (prev_solution[i] - current_solution[i]));\n                end\n            end\n            \n            // Check if error is below threshold\n            converged <= (error_accumulator[DATA_BITS+8-1:8] < threshold);\n        end\n    end\n    \nendmodule\"\"\"\n    \n    def generate_constraints_file(\n        self,\n        crossbar_size: int,\n        target_frequency_mhz: float = None\n    ) -> str:\n        \"\"\"Generate constraints file for FPGA implementation.\n        \n        Args:\n            crossbar_size: Size of crossbar arrays\n            target_frequency_mhz: Target clock frequency\n            \n        Returns:\n            Constraints file content\n        \"\"\"\n        freq_mhz = target_frequency_mhz or self.config.clock_frequency_mhz\n        period_ns = 1000.0 / freq_mhz\n        \n        if self.config.target_technology.startswith(\"xilinx\"):\n            # Xilinx XDC format\n            return f\"\"\"\n# Analog PDE Solver Constraints\n# Generated for {self.config.target_technology}\n\n# Clock constraints\ncreate_clock -period {period_ns:.3f} [get_ports clk]\nset_clock_uncertainty 0.1 [get_clocks clk]\n\n# Input/Output delays\nset_input_delay -clock [get_clocks clk] 2.0 [get_ports {{boundary_values[*] config_data config_valid start_solve}}]\nset_output_delay -clock [get_clocks clk] 2.0 [get_ports {{solution[*] solution_valid solve_complete converged}}]\n\n# False paths for reset\nset_false_path -from [get_ports rst_n]\n\n# Memory placement constraints\nset_property RAM_STYLE \"{self.config.memory_type.upper()}\" [get_cells {{*g_positive* *g_negative*}}]\n\n# Placement constraints for critical paths\nset_property LOC SLICE_X0Y0 [get_cells {{crossbar_0/*}}]\n\n# Timing constraints for crossbar operations\nset_max_delay 8.0 -from [get_cells {{crossbar_inputs*}}] -to [get_cells {{crossbar_outputs*}}]\n\"\"\"\n        else:\n            # Generic SDC format\n            return f\"\"\"\n# Analog PDE Solver Constraints\n# Generic SDC format\n\ncreate_clock -name clk -period {period_ns:.3f} [get_ports clk]\nset_clock_uncertainty 0.1 [get_clocks clk]\n\nset_input_delay -clock clk 2.0 [get_ports {{boundary_values* config_data config_valid start_solve}}]\nset_output_delay -clock clk 2.0 [get_ports {{solution* solution_valid solve_complete converged}}]\n\nset_false_path -from [get_ports rst_n]\n\"\"\"\n    \n    def export_all_modules(self, output_dir: Path) -> Dict[str, Path]:\n        \"\"\"Export all generated modules to files.\n        \n        Args:\n            output_dir: Directory to write Verilog files\n            \n        Returns:\n            Dictionary mapping module names to file paths\n        \"\"\"\n        output_dir = Path(output_dir)\n        output_dir.mkdir(parents=True, exist_ok=True)\n        \n        exported_files = {}\n        \n        for module_name, verilog_code in self.generated_modules.items():\n            file_path = output_dir / f\"{module_name}.v\"\n            \n            with open(file_path, 'w') as f:\n                f.write(verilog_code)\n            \n            exported_files[module_name] = file_path\n            self.logger.info(f\"Exported {module_name} to {file_path}\")\n        \n        # Generate constraints file\n        constraints_content = self.generate_constraints_file(128)  # Default size\n        constraints_ext = \"xdc\" if \"xilinx\" in self.config.target_technology else \"sdc\"\n        constraints_path = output_dir / f\"analog_pde_solver.{constraints_ext}\"\n        \n        with open(constraints_path, 'w') as f:\n            f.write(constraints_content)\n        \n        exported_files[\"constraints\"] = constraints_path\n        \n        # Generate convergence detector\n        conv_detector_code = self.generate_convergence_detector()\n        conv_detector_path = output_dir / \"convergence_detector.v\"\n        \n        with open(conv_detector_path, 'w') as f:\n            f.write(conv_detector_code)\n        \n        exported_files[\"convergence_detector\"] = conv_detector_path\n        \n        self.logger.info(f\"Exported {len(exported_files)} files to {output_dir}\")\n        return exported_files\n    \n    def generate_testbench(\n        self,\n        module_name: str,\n        crossbar_size: int\n    ) -> str:\n        \"\"\"Generate testbench for generated modules.\n        \n        Args:\n            module_name: Name of module to test\n            crossbar_size: Size of crossbar for test vectors\n            \n        Returns:\n            Verilog testbench code\n        \"\"\"\n        return f\"\"\"\n// Testbench for {module_name}\n// Generated by Terragon Labs Analog PDE Solver\n\n`timescale 1ns/1ps\n\nmodule tb_{module_name};\n    \n    // Parameters\n    parameter GRID_SIZE = {crossbar_size};\n    parameter DAC_BITS = {self.config.dac_bits};\n    parameter ADC_BITS = {self.config.adc_bits};\n    parameter CLK_PERIOD = {1000.0 / self.config.clock_frequency_mhz:.1f}; // ns\n    \n    // Testbench signals\n    reg clk;\n    reg rst_n;\n    reg [DAC_BITS-1:0] boundary_values [0:GRID_SIZE-1];\n    reg boundary_valid;\n    reg start_solve;\n    \n    wire [ADC_BITS-1:0] solution [0:GRID_SIZE-1];\n    wire solution_valid;\n    wire solve_complete;\n    wire converged;\n    wire [15:0] iterations_count;\n    wire [31:0] debug_status;\n    wire error;\n    \n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #(CLK_PERIOD/2) clk = ~clk;\n    end\n    \n    // DUT instantiation\n    {module_name} dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .boundary_values(boundary_values),\n        .boundary_valid(boundary_valid),\n        .solution(solution),\n        .solution_valid(solution_valid),\n        .start_solve(start_solve),\n        .solve_complete(solve_complete),\n        .converged(converged),\n        .iterations_count(iterations_count),\n        .debug_status(debug_status),\n        .error(error),\n        .config_data(32'h0),\n        .config_valid(1'b0),\n        .config_ready()\n    );\n    \n    // Test stimulus\n    initial begin\n        $dumpfile(\"{module_name}_tb.vcd\");\n        $dumpvars(0, tb_{module_name});\n        \n        // Initialize\n        rst_n = 0;\n        boundary_valid = 0;\n        start_solve = 0;\n        \n        // Initialize boundary conditions\n        for (int i = 0; i < GRID_SIZE; i++) begin\n            boundary_values[i] = (i == 0 || i == GRID_SIZE-1) ? 8'h00 : 8'h80;\n        end\n        \n        // Reset sequence\n        #(CLK_PERIOD * 10);\n        rst_n = 1;\n        #(CLK_PERIOD * 5);\n        \n        // Start solve\n        boundary_valid = 1;\n        start_solve = 1;\n        #(CLK_PERIOD);\n        start_solve = 0;\n        \n        // Wait for completion\n        wait(solve_complete);\n        \n        $display(\"Solution completed!\");\n        $display(\"Converged: %b\", converged);\n        $display(\"Iterations: %d\", iterations_count);\n        \n        // Display solution\n        for (int i = 0; i < GRID_SIZE; i++) begin\n            $display(\"solution[%2d] = %h\", i, solution[i]);\n        end\n        \n        #(CLK_PERIOD * 100);\n        $finish;\n    end\n    \n    // Timeout watchdog\n    initial begin\n        #(CLK_PERIOD * 100000);  // 100k cycles max\n        $display(\"ERROR: Testbench timeout!\");\n        $finish;\n    end\n    \nendmodule\n\"\"\""}, {"old_string": "    def _generate_heat_controller(self, size: int) -> str:\n        \"\"\"Generate heat equation controller.\"\"\"\n        pass\n    \n    def _generate_navier_stokes_controller(self, size: int) -> str:\n        \"\"\"Generate Navier-Stokes controller.\"\"\"\n        pass", "new_string": "    def _generate_heat_controller(self, size: int) -> str:\n        \"\"\"Generate heat equation controller.\"\"\"\n        return f\"\"\"\n// Heat equation controller\nmodule pde_controller_heat #(\n    parameter GRID_SIZE = {size}\n)(\n    input wire clk,\n    input wire rst_n,\n    output wire [31:0] heat_status\n);\n    assign heat_status = 32'h00000002;  // Heat equation type\nendmodule\"\"\"\n    \n    def _generate_navier_stokes_controller(self, size: int) -> str:\n        \"\"\"Generate Navier-Stokes controller.\"\"\"\n        return f\"\"\"\n// Navier-Stokes equation controller\nmodule pde_controller_navier_stokes #(\n    parameter GRID_SIZE = {size}\n)(\n    input wire clk,\n    input wire rst_n,\n    output wire [31:0] ns_status\n);\n    assign ns_status = 32'h00000003;  // Navier-Stokes type\nendmodule\"\"\""}]